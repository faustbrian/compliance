<?php declare(strict_types=1);

/**
 * Copyright (C) Brian Faust
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

use Cline\Prism\Contracts\PrismTestInterface;
use Cline\Prism\Contracts\ValidationResult;
use Cline\Prism\Services\PrismRunner;
use Cline\Prism\Services\ValidatorComparisonService;
use Cline\Prism\ValueObjects\TestResult;
use Cline\Prism\ValueObjects\TestSuite;

/**
 * Test helper that implements PrismTestInterface with predefined results.
 */
class TestPrismValidator implements PrismTestInterface
{
    public function __construct(
        private string $name,
        private array $results,
    ) {}

    public function getName(): string
    {
        return $this->name;
    }

    public function getValidatorClass(): string
    {
        return 'TestValidator';
    }

    public function getTestDirectory(): string
    {
        return '/tmp/test';
    }

    public function validate(mixed $data, mixed $schema): ValidationResult
    {
        return new class() implements ValidationResult {
            public function isValid(): bool
            {
                return true;
            }

            public function errors(): array
            {
                return [];
            }
        };
    }

    public function getTestFilePatterns(): array
    {
        return ['*.json'];
    }

    public function decodeJson(string $json): mixed
    {
        return json_decode($json, true);
    }

    public function shouldIncludeFile(string $filePath): bool
    {
        return true;
    }

    public function getResults(): array
    {
        return $this->results;
    }
}

/**
 * Test runner wrapper that allows setting predefined results.
 */
class TestRunnerWrapper
{
    private array $suites = [];

    public function setSuite(string $validatorName, TestSuite $suite): void
    {
        $this->suites[$validatorName] = $suite;
    }

    public function run(PrismTestInterface $prism): TestSuite
    {
        return $this->suites[$prism->getName()] ?? new TestSuite(
            name: $prism->getName(),
            results: [],
            duration: 0.0,
        );
    }

    public function toPrismRunner(): object
    {
        $suites = $this->suites;

        return new class($suites) {
            public function __construct(private array $suites) {}

            public function run(PrismTestInterface $prism, ?array $fileList = null, mixed $progressService = null): TestSuite
            {
                return $this->suites[$prism->getName()] ?? new TestSuite(
                    name: $prism->getName(),
                    results: [],
                    duration: 0.0,
                );
            }
        };
    }
}

describe('ValidatorComparisonService', function (): void {
    describe('compare()', function (): void {
        describe('validator count validation', function (): void {
            test('returns error when no validators provided', function (): void {
                // Arrange
                $service = new ValidatorComparisonService();
                $runner = new PrismRunner();
                $validators = [];

                // Act
                $result = $service->compare($validators, $runner);

                // Assert
                expect($result)->toBe([
                    'error' => 'At least two validators required for comparison',
                    'discrepancies' => [],
                ]);
            });

            test('returns error when only one validator provided', function (): void {
                // Arrange
                $service = new ValidatorComparisonService();
                $runnerWrapper = new TestRunnerWrapper();
                $runner = $runnerWrapper->toPrismRunner();

                $validator1 = new TestPrismValidator('validator1', []);
                $validators = ['validator1' => $validator1];

                // Act
                $result = $service->compare($validators, $runner);

                // Assert
                expect($result)->toBe([
                    'error' => 'At least two validators required for comparison',
                    'discrepancies' => [],
                ]);
            });
        });

        describe('with two validators', function (): void {
            test('returns comparison with no discrepancies when validators agree', function (): void {
                // Arrange
                $service = new ValidatorComparisonService();

                $validator1 = Mockery::mock(PrismTestInterface::class);
                $validator2 = Mockery::mock(PrismTestInterface::class);

                $validators = [
                    'validator1' => $validator1,
                    'validator2' => $validator2,
                ];

                $testResult1 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case 1',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: true,
                    passed: true,
                );

                $testResult2 = new TestResult(
                    id: 'test:file:0:1',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case 2',
                    data: ['key' => 'invalid'],
                    expectedValid: false,
                    actualValid: false,
                    passed: true,
                );

                $suite1 = new TestSuite(
                    name: 'validator1',
                    results: [$testResult1, $testResult2],
                    duration: 0.1,
                );

                $suite2 = new TestSuite(
                    name: 'validator2',
                    results: [$testResult1, $testResult2],
                    duration: 0.1,
                );

                $runner = Mockery::mock(PrismRunner::class);
                $runner->shouldReceive('run')
                    ->with($validator1)
                    ->once()
                    ->andReturn($suite1);
                $runner->shouldReceive('run')
                    ->with($validator2)
                    ->once()
                    ->andReturn($suite2);

                // Act
                $result = $service->compare($validators, $runner);

                // Assert
                expect($result['validators'])->toBe(['validator1', 'validator2']);
                expect($result['total_tests'])->toBe(2);
                expect($result['discrepancies_count'])->toBe(0);
                expect($result['discrepancies'])->toBe([]);
            });

            test('returns comparison with discrepancies when validators disagree', function (): void {
                // Arrange
                $service = new ValidatorComparisonService();

                $validator1 = Mockery::mock(PrismTestInterface::class);
                $validator2 = Mockery::mock(PrismTestInterface::class);

                $validators = [
                    'validator1' => $validator1,
                    'validator2' => $validator2,
                ];

                $testResult1V1 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case with disagreement',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: true,
                    passed: true,
                );

                $testResult1V2 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case with disagreement',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: false,
                    passed: false,
                );

                $suite1 = new TestSuite(
                    name: 'validator1',
                    results: [$testResult1V1],
                    duration: 0.1,
                );

                $suite2 = new TestSuite(
                    name: 'validator2',
                    results: [$testResult1V2],
                    duration: 0.1,
                );

                $runner = Mockery::mock(PrismRunner::class);
                $runner->shouldReceive('run')
                    ->with($validator1)
                    ->once()
                    ->andReturn($suite1);
                $runner->shouldReceive('run')
                    ->with($validator2)
                    ->once()
                    ->andReturn($suite2);

                // Act
                $result = $service->compare($validators, $runner);

                // Assert
                expect($result['validators'])->toBe(['validator1', 'validator2']);
                expect($result['total_tests'])->toBe(1);
                expect($result['discrepancies_count'])->toBe(1);
                expect($result['discrepancies'])->toHaveCount(1);
                expect($result['discrepancies'][0]['test_id'])->toBe('test:file:0:0');
                expect($result['discrepancies'][0]['description'])->toBe('Test case with disagreement');
                expect($result['discrepancies'][0]['outcomes']['validator1']['actualValid'])->toBeTrue();
                expect($result['discrepancies'][0]['outcomes']['validator2']['actualValid'])->toBeFalse();
                expect($result['discrepancies'][0]['agreement'])->toBe('50.0%');
            });
        });

        describe('with three validators', function (): void {
            test('calculates 66.7% agreement when two out of three validators agree', function (): void {
                // Arrange
                $service = new ValidatorComparisonService();

                $validator1 = Mockery::mock(PrismTestInterface::class);
                $validator2 = Mockery::mock(PrismTestInterface::class);
                $validator3 = Mockery::mock(PrismTestInterface::class);

                $validators = [
                    'validator1' => $validator1,
                    'validator2' => $validator2,
                    'validator3' => $validator3,
                ];

                $testResult1V1 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: true,
                    passed: true,
                );

                $testResult1V2 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: true,
                    passed: true,
                );

                $testResult1V3 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: false,
                    passed: false,
                );

                $suite1 = new TestSuite(
                    name: 'validator1',
                    results: [$testResult1V1],
                    duration: 0.1,
                );

                $suite2 = new TestSuite(
                    name: 'validator2',
                    results: [$testResult1V2],
                    duration: 0.1,
                );

                $suite3 = new TestSuite(
                    name: 'validator3',
                    results: [$testResult1V3],
                    duration: 0.1,
                );

                $runner = Mockery::mock(PrismRunner::class);
                $runner->shouldReceive('run')
                    ->with($validator1)
                    ->once()
                    ->andReturn($suite1);
                $runner->shouldReceive('run')
                    ->with($validator2)
                    ->once()
                    ->andReturn($suite2);
                $runner->shouldReceive('run')
                    ->with($validator3)
                    ->once()
                    ->andReturn($suite3);

                // Act
                $result = $service->compare($validators, $runner);

                // Assert
                expect($result['validators'])->toBe(['validator1', 'validator2', 'validator3']);
                expect($result['total_tests'])->toBe(1);
                expect($result['discrepancies_count'])->toBe(1);
                expect($result['discrepancies'][0]['agreement'])->toBe('66.7%');
            });
        });

        describe('with four validators', function (): void {
            test('calculates 75% agreement when three out of four validators agree', function (): void {
                // Arrange
                $service = new ValidatorComparisonService();

                $validator1 = Mockery::mock(PrismTestInterface::class);
                $validator2 = Mockery::mock(PrismTestInterface::class);
                $validator3 = Mockery::mock(PrismTestInterface::class);
                $validator4 = Mockery::mock(PrismTestInterface::class);

                $validators = [
                    'validator1' => $validator1,
                    'validator2' => $validator2,
                    'validator3' => $validator3,
                    'validator4' => $validator4,
                ];

                $testResult1V1 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: false,
                    passed: false,
                );

                $testResult1V2 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: false,
                    passed: false,
                );

                $testResult1V3 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: false,
                    passed: false,
                );

                $testResult1V4 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: true,
                    passed: true,
                );

                $suite1 = new TestSuite(
                    name: 'validator1',
                    results: [$testResult1V1],
                    duration: 0.1,
                );

                $suite2 = new TestSuite(
                    name: 'validator2',
                    results: [$testResult1V2],
                    duration: 0.1,
                );

                $suite3 = new TestSuite(
                    name: 'validator3',
                    results: [$testResult1V3],
                    duration: 0.1,
                );

                $suite4 = new TestSuite(
                    name: 'validator4',
                    results: [$testResult1V4],
                    duration: 0.1,
                );

                $runner = Mockery::mock(PrismRunner::class);
                $runner->shouldReceive('run')
                    ->with($validator1)
                    ->once()
                    ->andReturn($suite1);
                $runner->shouldReceive('run')
                    ->with($validator2)
                    ->once()
                    ->andReturn($suite2);
                $runner->shouldReceive('run')
                    ->with($validator3)
                    ->once()
                    ->andReturn($suite3);
                $runner->shouldReceive('run')
                    ->with($validator4)
                    ->once()
                    ->andReturn($suite4);

                // Act
                $result = $service->compare($validators, $runner);

                // Assert
                expect($result['validators'])->toBe(['validator1', 'validator2', 'validator3', 'validator4']);
                expect($result['total_tests'])->toBe(1);
                expect($result['discrepancies_count'])->toBe(1);
                expect($result['discrepancies'][0]['agreement'])->toBe('75.0%');
            });
        });

        describe('with multiple test cases', function (): void {
            test('identifies all discrepancies across multiple tests', function (): void {
                // Arrange
                $service = new ValidatorComparisonService();

                $validator1 = Mockery::mock(PrismTestInterface::class);
                $validator2 = Mockery::mock(PrismTestInterface::class);

                $validators = [
                    'validator1' => $validator1,
                    'validator2' => $validator2,
                ];

                // Test 1: Agreement
                $testResult1V1 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Agreeing test case',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: true,
                    passed: true,
                );

                $testResult1V2 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Agreeing test case',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: true,
                    passed: true,
                );

                // Test 2: Disagreement
                $testResult2V1 = new TestResult(
                    id: 'test:file:0:1',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Disagreeing test case',
                    data: ['key' => 'invalid'],
                    expectedValid: false,
                    actualValid: false,
                    passed: true,
                );

                $testResult2V2 = new TestResult(
                    id: 'test:file:0:1',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Disagreeing test case',
                    data: ['key' => 'invalid'],
                    expectedValid: false,
                    actualValid: true,
                    passed: false,
                );

                // Test 3: Agreement
                $testResult3V1 = new TestResult(
                    id: 'test:file:1:0',
                    file: 'test.json',
                    group: 'Test Group 2',
                    description: 'Another agreeing test',
                    data: null,
                    expectedValid: false,
                    actualValid: false,
                    passed: true,
                );

                $testResult3V2 = new TestResult(
                    id: 'test:file:1:0',
                    file: 'test.json',
                    group: 'Test Group 2',
                    description: 'Another agreeing test',
                    data: null,
                    expectedValid: false,
                    actualValid: false,
                    passed: true,
                );

                $suite1 = new TestSuite(
                    name: 'validator1',
                    results: [$testResult1V1, $testResult2V1, $testResult3V1],
                    duration: 0.1,
                );

                $suite2 = new TestSuite(
                    name: 'validator2',
                    results: [$testResult1V2, $testResult2V2, $testResult3V2],
                    duration: 0.1,
                );

                $runner = Mockery::mock(PrismRunner::class);
                $runner->shouldReceive('run')
                    ->with($validator1)
                    ->once()
                    ->andReturn($suite1);
                $runner->shouldReceive('run')
                    ->with($validator2)
                    ->once()
                    ->andReturn($suite2);

                // Act
                $result = $service->compare($validators, $runner);

                // Assert
                expect($result['validators'])->toBe(['validator1', 'validator2']);
                expect($result['total_tests'])->toBe(3);
                expect($result['discrepancies_count'])->toBe(1);
                expect($result['discrepancies'])->toHaveCount(1);
                expect($result['discrepancies'][0]['test_id'])->toBe('test:file:0:1');
                expect($result['discrepancies'][0]['description'])->toBe('Disagreeing test case');
            });
        });

        describe('edge cases', function (): void {
            test('handles missing test ID in one validator', function (): void {
                // Arrange
                $service = new ValidatorComparisonService();

                $validator1 = Mockery::mock(PrismTestInterface::class);
                $validator2 = Mockery::mock(PrismTestInterface::class);

                $validators = [
                    'validator1' => $validator1,
                    'validator2' => $validator2,
                ];

                $testResult1 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case 1',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: true,
                    passed: true,
                );

                $testResult2 = new TestResult(
                    id: 'test:file:0:1',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case 2',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: true,
                    passed: true,
                );

                // validator1 has both tests, validator2 only has test 0:1
                $suite1 = new TestSuite(
                    name: 'validator1',
                    results: [$testResult1, $testResult2],
                    duration: 0.1,
                );

                $suite2 = new TestSuite(
                    name: 'validator2',
                    results: [$testResult2],
                    duration: 0.1,
                );

                $runner = Mockery::mock(PrismRunner::class);
                $runner->shouldReceive('run')
                    ->with($validator1)
                    ->once()
                    ->andReturn($suite1);
                $runner->shouldReceive('run')
                    ->with($validator2)
                    ->once()
                    ->andReturn($suite2);

                // Act
                $result = $service->compare($validators, $runner);

                // Assert
                expect($result['validators'])->toBe(['validator1', 'validator2']);
                expect($result['total_tests'])->toBe(2);
                // Only one validator has test:file:0:0, so it's skipped in comparison
                expect($result['discrepancies_count'])->toBe(0);
            });

            test('handles empty test results from all validators', function (): void {
                // Arrange
                $service = new ValidatorComparisonService();

                $validator1 = Mockery::mock(PrismTestInterface::class);
                $validator2 = Mockery::mock(PrismTestInterface::class);

                $validators = [
                    'validator1' => $validator1,
                    'validator2' => $validator2,
                ];

                $suite1 = new TestSuite(
                    name: 'validator1',
                    results: [],
                    duration: 0.0,
                );

                $suite2 = new TestSuite(
                    name: 'validator2',
                    results: [],
                    duration: 0.0,
                );

                $runner = Mockery::mock(PrismRunner::class);
                $runner->shouldReceive('run')
                    ->with($validator1)
                    ->once()
                    ->andReturn($suite1);
                $runner->shouldReceive('run')
                    ->with($validator2)
                    ->once()
                    ->andReturn($suite2);

                // Act
                $result = $service->compare($validators, $runner);

                // Assert
                expect($result['validators'])->toBe(['validator1', 'validator2']);
                expect($result['total_tests'])->toBe(0);
                expect($result['discrepancies_count'])->toBe(0);
                expect($result['discrepancies'])->toBe([]);
            });

            test('handles validators with different expectedValid values but same actualValid', function (): void {
                // Arrange
                $service = new ValidatorComparisonService();

                $validator1 = Mockery::mock(PrismTestInterface::class);
                $validator2 = Mockery::mock(PrismTestInterface::class);

                $validators = [
                    'validator1' => $validator1,
                    'validator2' => $validator2,
                ];

                $testResult1V1 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: true,
                    passed: true,
                );

                $testResult1V2 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case',
                    data: ['key' => 'value'],
                    expectedValid: false,  // Different expected
                    actualValid: true,      // Same actual
                    passed: false,
                );

                $suite1 = new TestSuite(
                    name: 'validator1',
                    results: [$testResult1V1],
                    duration: 0.1,
                );

                $suite2 = new TestSuite(
                    name: 'validator2',
                    results: [$testResult1V2],
                    duration: 0.1,
                );

                $runner = Mockery::mock(PrismRunner::class);
                $runner->shouldReceive('run')
                    ->with($validator1)
                    ->once()
                    ->andReturn($suite1);
                $runner->shouldReceive('run')
                    ->with($validator2)
                    ->once()
                    ->andReturn($suite2);

                // Act
                $result = $service->compare($validators, $runner);

                // Assert
                // Same actualValid means no discrepancy
                expect($result['discrepancies_count'])->toBe(0);
            });

            test('includes all outcome details in discrepancy report', function (): void {
                // Arrange
                $service = new ValidatorComparisonService();

                $validator1 = Mockery::mock(PrismTestInterface::class);
                $validator2 = Mockery::mock(PrismTestInterface::class);

                $validators = [
                    'validator1' => $validator1,
                    'validator2' => $validator2,
                ];

                $testResult1V1 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case',
                    data: ['key' => 'value'],
                    expectedValid: true,
                    actualValid: true,
                    passed: true,
                );

                $testResult1V2 = new TestResult(
                    id: 'test:file:0:0',
                    file: 'test.json',
                    group: 'Test Group',
                    description: 'Test case',
                    data: ['key' => 'value'],
                    expectedValid: false,
                    actualValid: false,
                    passed: true,
                );

                $suite1 = new TestSuite(
                    name: 'validator1',
                    results: [$testResult1V1],
                    duration: 0.1,
                );

                $suite2 = new TestSuite(
                    name: 'validator2',
                    results: [$testResult1V2],
                    duration: 0.1,
                );

                $runner = Mockery::mock(PrismRunner::class);
                $runner->shouldReceive('run')
                    ->with($validator1)
                    ->once()
                    ->andReturn($suite1);
                $runner->shouldReceive('run')
                    ->with($validator2)
                    ->once()
                    ->andReturn($suite2);

                // Act
                $result = $service->compare($validators, $runner);

                // Assert
                expect($result['discrepancies_count'])->toBe(1);
                expect($result['discrepancies'][0]['outcomes']['validator1'])->toBe([
                    'passed' => true,
                    'actualValid' => true,
                    'expectedValid' => true,
                ]);
                expect($result['discrepancies'][0]['outcomes']['validator2'])->toBe([
                    'passed' => true,
                    'actualValid' => false,
                    'expectedValid' => false,
                ]);
            });
        });
    });
});
